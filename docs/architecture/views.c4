// Backsplash - Tile Map Editor Architecture
// C4 Views: System Context, Container, Component, and Dynamic diagrams

views {

  // ════════════════════════════════════════════════════════════════
  // Static Views — Structure
  // ════════════════════════════════════════════════════════════════

  // ── Level 1: System Context ─────────────────────────────────────
  view systemContext of backsplash {
    title 'Backsplash — System Context'
    description '''
      How Backsplash fits into the game developer's workflow.
      The editor loads tileset images from the filesystem,
      provides a browser-based editing experience, and exports
      tilemap data for consumption by game engines.
    '''

    include
      gamedev,
      backsplash,
      filesystem,
      gameEngine,
      componentLib

    style filesystem {
      color slate
    }
    style gameEngine {
      color slate
    }
    style componentLib {
      color muted
    }
  }

  // ── Level 2: Container Diagram ──────────────────────────────────
  view containers of backsplash {
    title 'Backsplash — Containers'
    description '''
      The editor is a single-page web application. It imports
      UI primitives from the bh-01 component library and
      interacts with the local filesystem for images and projects.
    '''

    include
      gamedev,
      backsplash.*,
      filesystem,
      gameEngine,
      componentLib

    style filesystem {
      color slate
    }
    style gameEngine {
      color slate
    }
    style componentLib {
      color muted
    }
  }

  // ── Level 3: Components — Full Editor ───────────────────────────
  view components of backsplash.editorApp {
    title 'Editor Application — Components'
    description '''
      Internal structure of the editor application. Core domain
      models (green) are pure TypeScript with no UI dependency.
      The Editor Store (amber) is the reactive state hub. UI
      components (blue) subscribe to the store and dispatch
      mutations through the domain models.
    '''

    include *

    style editorStore {
      color amber
    }
    style tilesetModel {
      color green
    }
    style tilemapModel {
      color green
    }
    style layerModel {
      color green
    }
    style selectionModel {
      color green
    }
    style toolEngine {
      color green
    }
    style historyManager {
      color green
    }
    style serializer {
      color green
    }
    style tileDetector {
      color red
    }
  }

  // ════════════════════════════════════════════════════════════════
  // Dynamic Views — User Flows
  // ════════════════════════════════════════════════════════════════

  // ── Flow 1: New Map Creation (PLANNED) ───────────────────────
  // Currently the editor auto-creates a demo tilemap on load.
  // A proper "New Map" dialog is planned for a future milestone.

  // ── Flow 2: Open Existing Project (PLANNED — M7) ───────────
  // Depends on the Serializer component (planned M7).

  // ── Flow 3: Tileset Import ────────────────────────────────────
  dynamic view importFlow {
    title 'Tileset Import Flow'
    description '''
      User loads a spritesheet image. The tile size detector
      runs in a Web Worker, analyzes the image, and presents
      ranked candidates. The user confirms or overrides the
      tile size, and the tileset is created.
    '''

    // User drops/selects an image file
    gamedev -> backsplash.editorApp.importDialog 'drops spritesheet image' {
      notes '''
        Via drag-and-drop, file picker, or clipboard paste.
        The raw image is loaded as an ImageBitmap and its
        pixel data is transferred to the Web Worker.
      '''
    }

    // Dialog posts image data to worker
    backsplash.editorApp.importDialog -> backsplash.editorApp.tileDetector 'posts pixel data to worker' {
      notes '''
        Uses postMessage with transferable ImageBitmap to
        avoid copying pixel data to the worker thread.
      '''
    }

    // Detector runs heuristics in worker thread
    backsplash.editorApp.tileDetector -> backsplash.editorApp.tileDetector 'runs detection heuristics' {
      notes '''
        1. Check divisibility by common sizes (8, 16, 32, 64)
        2. Scan for grid lines (transparent/uniform pixel rows+cols)
        3. Analyze color transition frequency
        4. Rank candidates by confidence score
        All runs off main thread via OffscreenCanvas.
      '''
    }

    // Worker posts candidates back
    backsplash.editorApp.importDialog <- backsplash.editorApp.tileDetector 'returns ranked size candidates'

    // Dialog shows preview with grid overlay for user confirmation
    backsplash.editorApp.importDialog -> gamedev 'shows grid overlay preview' {
      notes '''
        Renders the spritesheet with the top candidate's grid
        overlaid. User can accept, pick another candidate,
        or enter a custom tile size + margin/spacing.
      '''
    }

    // User confirms, tileset is created
    gamedev -> backsplash.editorApp.importDialog 'confirms tile size'
    backsplash.editorApp.importDialog -> backsplash.editorApp.tilesetModel 'creates tileset from confirmed grid'

    // Store notifies UI
    backsplash.editorApp.tilesetModel -> backsplash.editorApp.editorStore 'registers new tileset'
    backsplash.editorApp.editorStore -> backsplash.editorApp.tilesetPanel 'emits updated tileset list'
  }

  // ── Flow 4: Stamp Selection (PLANNED — M6) ───────────────────
  // Multi-tile stamp selection via drag in the tileset panel.
  // Depends on SelectionModel multi-tile support (planned M6).

  // ── Flow 5: Tile Painting ─────────────────────────────────────
  dynamic view paintFlow {
    title 'Tile Painting Flow'
    description '''
      The primary editing loop. User selects a tile from the
      tileset panel, paints on the canvas via click/drag, and
      the map cells are updated immediately. The canvas
      schedules its own re-render after each mutation.
    '''

    // Select a tile from the palette
    gamedev -> backsplash.editorApp.tilesetPanel 'clicks tile in palette'
    backsplash.editorApp.tilesetPanel -> backsplash.editorApp.selectionModel 'shell updates selectedGid on bs-tile-select'

    // Select brush tool
    gamedev -> backsplash.editorApp.toolbar 'selects brush tool'
    backsplash.editorApp.toolbar -> backsplash.editorApp.editorStore 'shell sets active tool to brush'

    // Paint on the canvas
    gamedev -> backsplash.editorApp.mapCanvas 'clicks/drags on map cell'
    backsplash.editorApp.mapCanvas -> backsplash.editorApp.toolEngine 'dispatches pointer event with cell coords and EditorState'

    // Tool engine applies mutation
    backsplash.editorApp.toolEngine -> backsplash.editorApp.tilemapModel 'writes GID to cell on active layer'

    // Canvas re-renders
    backsplash.editorApp.mapCanvas -> backsplash.editorApp.tilesetModel 'fetches tile image for painted GID'
  }

  // ── Flow 6: Bucket Fill (PLANNED — M4) ──────────────────────
  // Depends on ToolEngine fill strategy and HistoryManager.

  // ── Flow 7: Undo / Redo (PLANNED — M4) ──────────────────────
  // Depends on HistoryManager component. Tool Engine already
  // produces Command objects in preparation.

  // ── Flow 8: Save / Export (PLANNED — M7) ────────────────────
  // Depends on Serializer component.

  // ── Flow 9: Layer Management (PLANNED — M5) ─────────────────
  // Depends on Layer Panel becoming a real component with
  // interaction handlers.

  // ── Flow 10: Object Placement (PLANNED) ─────────────────────
  // Depends on object layer support in ToolEngine and
  // LayerModel object layer API.
}
