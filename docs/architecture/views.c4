// Backsplash - Tile Map Editor Architecture
// C4 Views: System Context, Container, Component, and Dynamic diagrams

views {

  // ════════════════════════════════════════════════════════════════
  // Static Views — Structure
  // ════════════════════════════════════════════════════════════════

  // ── Level 1: System Context ─────────────────────────────────────
  view systemContext of backsplash {
    title 'Backsplash — System Context'
    description '''
      How Backsplash fits into the game developer's workflow.
      The editor loads tileset images from the filesystem,
      provides a browser-based editing experience, and exports
      tilemap data for consumption by game engines.
    '''

    include
      gamedev,
      backsplash,
      filesystem,
      gameEngine,
      componentLib

    style filesystem {
      color slate
    }
    style gameEngine {
      color slate
    }
    style componentLib {
      color muted
    }
  }

  // ── Level 2: Container Diagram ──────────────────────────────────
  view containers of backsplash {
    title 'Backsplash — Containers'
    description '''
      The editor is a single-page web application. It imports
      UI primitives from the bh-01 component library and
      interacts with the local filesystem for images and projects.
    '''

    include
      gamedev,
      backsplash.*,
      filesystem,
      gameEngine,
      componentLib

    style filesystem {
      color slate
    }
    style gameEngine {
      color slate
    }
    style componentLib {
      color muted
    }
  }

  // ── Level 3: Components — Full Editor ───────────────────────────
  view components of backsplash.editorApp {
    title 'Editor Application — Components'
    description '''
      Internal structure of the editor application. Core domain
      models (green) are pure TypeScript with no UI dependency.
      The Editor Store (amber) holds state written by the shell.
      UI components (blue) receive props from the shell and emit
      events upward; the shell orchestrates all mutations.
    '''

    include *

    style editorStore {
      color amber
    }
    style tilesetModel {
      color green
    }
    style tilemapModel {
      color green
    }
    style layerModel {
      color green
    }
    style selectionModel {
      color green
    }
    style toolEngine {
      color green
    }
    style historyManager {
      color green
    }
    style serializer {
      color green
    }
    style tileDetector {
      color red
    }
  }

  // ════════════════════════════════════════════════════════════════
  // Dynamic Views — User Flows
  // ════════════════════════════════════════════════════════════════

  // ── Flow 1: New Map Creation (PLANNED) ───────────────────────
  // Currently the editor auto-creates a demo tilemap on load.
  // A proper "New Map" dialog is planned for a future milestone.

  // ── Flow 2: Open Existing Project (PLANNED — M7) ───────────
  // Depends on the Serializer component (planned M7).

  // ── Flow 3: Tileset Import ────────────────────────────────────
  dynamic view importFlow {
    title 'Tileset Import Flow'
    description '''
      User loads a spritesheet image. The tile size detector
      runs in a Web Worker, analyzes the image, and presents
      ranked candidates. The user confirms or overrides the
      tile size, and the tileset is created.
    '''

    // User drops/selects an image file
    gamedev -> backsplash.editorApp.importDialog 'drops spritesheet image' {
      notes '''
        Via drag-and-drop, file picker, or clipboard paste.
        The raw image is loaded as an ImageBitmap and its
        pixel data is transferred to the Web Worker.
      '''
    }

    // Dialog posts image data to worker
    backsplash.editorApp.importDialog -> backsplash.editorApp.tileDetector 'posts pixel data to worker' {
      notes '''
        Uses postMessage with transferable ImageBitmap to
        avoid copying pixel data to the worker thread.
      '''
    }

    // Detector runs heuristics in worker thread
    backsplash.editorApp.tileDetector -> backsplash.editorApp.tileDetector 'runs detection heuristics' {
      notes '''
        1. Check divisibility by common sizes (8, 16, 32, 64)
        2. Scan for grid lines (transparent/uniform pixel rows+cols)
        3. Analyze color transition frequency
        4. Rank candidates by confidence score
        All runs off main thread via OffscreenCanvas.
      '''
    }

    // Worker posts candidates back
    backsplash.editorApp.importDialog <- backsplash.editorApp.tileDetector 'returns ranked size candidates'

    // Dialog shows preview with grid overlay for user confirmation
    backsplash.editorApp.importDialog -> gamedev 'shows grid overlay preview' {
      notes '''
        Renders the spritesheet with the top candidate's grid
        overlaid. User can accept, pick another candidate,
        or enter a custom tile size + margin/spacing.
      '''
    }

    // User confirms — shell handles bs-import-confirm event
    gamedev -> backsplash.editorApp.importDialog 'confirms tile size'
    backsplash.editorApp.importDialog -> backsplash.editorApp.tilesetModel 'shell creates tileset on bs-import-confirm'

    // Shell adds tileset to tilemap via tilemap.addTileset(tileset);
    // tilesetPanel receives updated tilesets via props
    backsplash.editorApp.tilemapModel -> backsplash.editorApp.tilesetModel 'shell registers tileset via tilemap.addTileset'
    backsplash.editorApp.tilesetPanel -> backsplash.editorApp.tilesetModel 'reads updated tilesets via props'
  }

  // ── Flow 4: Stamp Selection (PLANNED — M6) ───────────────────
  // Multi-tile stamp selection via drag in the tileset panel.
  // Depends on SelectionModel multi-tile support (planned M6).

  // ── Flow 5: Tile Painting ─────────────────────────────────────
  dynamic view paintFlow {
    title 'Tile Painting Flow'
    description '''
      The primary editing loop. User selects a tile from the
      tileset panel, paints on the canvas via click/drag, and
      the map cells are updated immediately. The canvas
      schedules its own re-render after each mutation.
    '''

    // Select a tile from the palette
    gamedev -> backsplash.editorApp.tilesetPanel 'clicks tile in palette'
    backsplash.editorApp.tilesetPanel -> backsplash.editorApp.selectionModel 'shell updates selectedGid on bs-tile-select'

    // Select brush tool
    gamedev -> backsplash.editorApp.toolbar 'selects brush tool'
    backsplash.editorApp.toolbar -> backsplash.editorApp.editorStore 'shell sets active tool to brush'

    // Paint on the canvas
    gamedev -> backsplash.editorApp.mapCanvas 'clicks/drags on map cell'
    backsplash.editorApp.mapCanvas -> backsplash.editorApp.toolEngine 'dispatches pointer event with cell coords and EditorState'

    // Tool engine applies mutation (called inline by canvas)
    backsplash.editorApp.toolEngine -> backsplash.editorApp.tilemapModel 'writes GID to cell on active layer'

    // Canvas emits bs-paint events; shell accumulates edits.
    // On bs-paint-end (pointer up), shell pushes one PaintCommand to history.
    backsplash.editorApp.mapCanvas -> backsplash.editorApp.historyManager 'shell batches stroke edits into one command on bs-paint-end'

    // Canvas re-renders
    backsplash.editorApp.mapCanvas -> backsplash.editorApp.tilesetModel 'fetches tile image for painted GID'
  }

  // ── Flow 6: Bucket Fill ─────────────────────────────────────
  dynamic view fillFlow {
    title 'Bucket Fill Flow'
    description '''
      Flood-fills a contiguous region of same-valued cells
      with the active tile using BFS (4-directional). Captured
      as a single undoable batch command. Bounded to 10k cells.
    '''

    gamedev -> backsplash.editorApp.toolbar 'selects fill tool (or presses G)'
    backsplash.editorApp.toolbar -> backsplash.editorApp.editorStore 'shell sets active tool to fill'

    gamedev -> backsplash.editorApp.mapCanvas 'clicks target cell'
    backsplash.editorApp.mapCanvas -> backsplash.editorApp.toolEngine 'dispatches pointer event with cell coords'

    backsplash.editorApp.toolEngine -> backsplash.editorApp.tilemapModel 'BFS flood fills contiguous cells with selected GID'
    backsplash.editorApp.mapCanvas -> backsplash.editorApp.historyManager 'shell pushes batch PaintCommand on bs-paint-end'

    backsplash.editorApp.mapCanvas -> backsplash.editorApp.tilesetModel 'fetches tile images for filled region'
  }

  // ── Flow 7: Undo / Redo ────────────────────────────────────
  dynamic view undoRedoFlow {
    title 'Undo / Redo Flow'
    description '''
      Every map mutation is reversible. Undo pops the last
      command and restores previous cell values. Redo re-applies.
      Keyboard shortcuts: Ctrl+Z / Ctrl+Shift+Z.
    '''

    gamedev -> backsplash.editorApp.toolbar 'clicks undo (or Ctrl+Z)'
    backsplash.editorApp.toolbar -> backsplash.editorApp.historyManager 'shell calls history.undo(tilemap)'
    backsplash.editorApp.historyManager -> backsplash.editorApp.tilemapModel 'restores previous cell values from command'
    backsplash.editorApp.tilemapModel -> backsplash.editorApp.mapCanvas 'shell calls requestUpdate(), canvas re-renders via props'
  }

  // ── Flow 8: Save / Export (PLANNED — M7) ────────────────────
  // Depends on Serializer component.

  // ── Flow 9: Layer Management ─────────────────────────────────
  dynamic view layerFlow {
    title 'Layer Management Flow'
    description '''
      User manages the layer stack via the Layer Panel. All
      operations (add, delete, rename, reorder, visibility,
      opacity, lock) are emitted as events and handled by
      the shell. Layer mutations are recorded in the History
      Manager for undo/redo support.
    '''

    gamedev -> backsplash.editorApp.layerPanel 'clicks add layer button'
    backsplash.editorApp.layerPanel -> backsplash.editorApp.tilemapModel 'shell adds new tile layer'
    backsplash.editorApp.layerPanel -> backsplash.editorApp.historyManager 'shell pushes AddLayerCommand'

    gamedev -> backsplash.editorApp.layerPanel 'clicks delete button on a layer'
    backsplash.editorApp.layerPanel -> backsplash.editorApp.tilemapModel 'shell calls removeLayer'
    backsplash.editorApp.layerPanel -> backsplash.editorApp.historyManager 'shell pushes DeleteLayerCommand'

    gamedev -> backsplash.editorApp.layerPanel 'double-clicks layer name'
    backsplash.editorApp.layerPanel -> backsplash.editorApp.tilemapModel 'shell renames layer via replaceLayer'
    backsplash.editorApp.layerPanel -> backsplash.editorApp.historyManager 'shell pushes RenameLayerCommand'

    gamedev -> backsplash.editorApp.layerPanel 'drags layer handle to reorder'
    backsplash.editorApp.layerPanel -> backsplash.editorApp.tilemapModel 'shell calls moveLayer'
    backsplash.editorApp.layerPanel -> backsplash.editorApp.historyManager 'shell pushes ReorderLayerCommand'
  }

  // ── Flow 10: Object Placement (PLANNED) ─────────────────────
  // Depends on object layer support in ToolEngine and
  // LayerModel object layer API.
}
